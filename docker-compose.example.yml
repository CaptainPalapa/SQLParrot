# SQL Parrot Docker Compose Example
# Copy this file to docker-compose.yml and customize for your environment
#
# ============================================================================
# SQL SERVER CONNECTION SCENARIOS
# ============================================================================
#
# SCENARIO 1: SQL Server running natively on your host machine (not in Docker)
#   SQL_SERVER=host.docker.internal
#   This special hostname lets containers reach services on your host machine.
#
# SCENARIO 2: SQL Server in a DIFFERENT Docker container/stack
#   If port 1433 is exposed to the host (ports: "1433:1433"):
#     SQL_SERVER=host.docker.internal
#   If port is NOT exposed, you need a shared Docker network between stacks:
#     SQL_SERVER=<container-name>  (e.g., "my-sql-server")
#     Plus: add both containers to the same external network (see Docker docs)
#
# SCENARIO 3: SQL Server in the SAME docker-compose stack (shared network)
#   SQL_SERVER=sql-server  (use the service name, not host.docker.internal)
#   No port exposure needed - containers on the same network talk directly.
#   See "SAME STACK EXAMPLE" at the bottom of this file.
#
# ============================================================================

services:
  sql-parrot:
    # OPTION 1: Use published image from GitHub Container Registry (recommended)
    # This pulls the latest release automatically. For a specific version, use:
    # image: ghcr.io/captainpalapa/sqlparrot:v1.3.0
    image: ghcr.io/captainpalapa/sqlparrot:latest

    # OPTION 2: Build from local Dockerfile (for development or custom builds)
    # Uncomment the line below and comment out the 'image:' line above
    # build: .

    ports:
      # Format: "HOST_PORT:CONTAINER_PORT"
      # Maps host port (left) to container port (right)
      # PORT=3000 below tells the app to listen on port 3000 inside the container
      - "${SQL_PARROT_BACKEND_PORT:-3000}:3000"  # Web UI and API served together

    # ========================================================================
    # APPROACH 1: Use .env file (Recommended - Keeps secrets out of compose file)
    # ========================================================================
    # Pass through all variables from .env file automatically.
    # This allows you to use ANY variable name in your profiles - just define
    # them in .env and reference them in profile fields with ${VAR_NAME} syntax.
    env_file:
      - .env

    environment:
      # Application Settings (these override .env if set)
      - NODE_ENV=production
      - PORT=3000  # Port the Node.js app listens on INSIDE the container

    # ========================================================================
    # APPROACH 2: Define variables directly in compose file (Alternative)
    # ========================================================================
    # If you prefer not to use a .env file, you can define variables directly
    # here. Uncomment the section below and comment out the env_file section above.
    #
    # environment:
    #   # Application Settings
    #   - NODE_ENV=production
    #   - PORT=3000
    #
    #   # SQL Server Connection (for use in profiles via ${VAR_NAME} syntax)
    #   - SQL_SERVER=host.docker.internal
    #   - SQL_USERNAME=your_username_here
    #   - SQL_PASSWORD=your_password_here
    #   - SQL_TRUST_CERTIFICATE=true
    #   - SNAPSHOT_PATH=/var/opt/mssql/snapshots
    #
    #   # For multiple profiles, add numbered variables:
    #   - SQL_SERVER_1=dev-server.example.com
    #   - SQL_USERNAME_1=dev_user
    #   - SQL_PASSWORD_1=dev_password
    #   - SNAPSHOT_PATH_1=/var/opt/mssql/snapshots
    #
    #   - SQL_SERVER_2=prod-server.example.com
    #   - SQL_USERNAME_2=prod_user
    #   - SQL_PASSWORD_2=prod_password
    #   - SNAPSHOT_PATH_2=C:\Snapshots
    #
    #   # Optional settings
    #   - SQLPARROT_USER_NAME=your_name_here
    #   - UI_PASSWORD=your_ui_password_here

    volumes:
      # IMPORTANT: Persist SQLite database (groups, snapshots metadata, settings, history)
      # Without this volume, your data is lost when the container is recreated!
      # Bind mount (recommended - easy to backup/inspect):
      - ./sqlparrot-data:/app/backend/data
      # Or use a named volume (Docker manages location):
      # - sqlparrot-data:/app/backend/data

    restart: unless-stopped
    healthcheck:
      # Using wget (available in Alpine) instead of curl
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:3000/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

# ============================================================================
# SAME STACK EXAMPLE (Scenario 3)
# ============================================================================
# Uncomment below to run SQL Server in the same stack as SQL Parrot.
# Note: Change SQL_SERVER above to "sql-server" (the service name).
#
#   sql-server:
#     image: mcr.microsoft.com/mssql/server:2022-latest
#     environment:
#       - ACCEPT_EULA=Y
#       - SA_PASSWORD=YourStrong@Passw0rd
#     # ports:                        # Port exposure is OPTIONAL in same-stack
#     #   - "1433:1433"               # Only needed if you want host access too
#     volumes:
#       - sql-data:/var/opt/mssql
#
# volumes:
#   sql-data:
#     driver: local
#
# networks:
#   sql-server-network:
#     driver: bridge
