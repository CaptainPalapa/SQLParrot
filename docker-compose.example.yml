# SQL Parrot Docker Compose Example
# Copy this file to docker-compose.yml and customize for your environment
#
# ============================================================================
# SQL SERVER CONNECTION SCENARIOS
# ============================================================================
#
# SCENARIO 1: SQL Server running natively on your host machine (not in Docker)
#   SQL_SERVER=host.docker.internal
#   This special hostname lets containers reach services on your host machine.
#
# SCENARIO 2: SQL Server in a DIFFERENT Docker container/stack
#   If port 1433 is exposed to the host (ports: "1433:1433"):
#     SQL_SERVER=host.docker.internal
#   If port is NOT exposed, you need a shared Docker network between stacks:
#     SQL_SERVER=<container-name>  (e.g., "my-sql-server")
#     Plus: add both containers to the same external network (see Docker docs)
#
# SCENARIO 3: SQL Server in the SAME docker-compose stack (shared network)
#   SQL_SERVER=sql-server  (use the service name, not host.docker.internal)
#   No port exposure needed - containers on the same network talk directly.
#   See "SAME STACK EXAMPLE" at the bottom of this file.
#
# ============================================================================
# CREDENTIAL OPTIONS
# ============================================================================
# 1. Create a .env file with SQL_SERVER, SQL_USERNAME, SQL_PASSWORD
# 2. Or set environment variables directly below
# 3. Or leave empty and configure via the web UI Settings tab
#    (saved to SQLite, persists across restarts)
# ============================================================================

services:
  sql-parrot:
    build: .
    ports:
      - "${SQL_PARROT_BACKEND_PORT:-3000}:3000"  # Web UI and API served together
    environment:
      # SQL Server Connection
      # See scenarios above - host.docker.internal works for Scenarios 1 & 2
      - SQL_SERVER=${SQL_SERVER:-host.docker.internal}
      - SQL_USERNAME=${SQL_USERNAME:-}
      - SQL_PASSWORD=${SQL_PASSWORD:-}
      - SQL_TRUST_CERTIFICATE=${SQL_TRUST_CERTIFICATE:-true}

      # Application Settings
      - NODE_ENV=production
      - PORT=3000

      # Snapshot Storage Path (where SQL Server stores snapshot files)
      # Must be accessible to SQL Server, not to this container
      - SNAPSHOT_PATH=${SNAPSHOT_PATH:-/var/opt/mssql/snapshots}
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

# ============================================================================
# SAME STACK EXAMPLE (Scenario 3)
# ============================================================================
# Uncomment below to run SQL Server in the same stack as SQL Parrot.
# Note: Change SQL_SERVER above to "sql-server" (the service name).
#
#   sql-server:
#     image: mcr.microsoft.com/mssql/server:2022-latest
#     environment:
#       - ACCEPT_EULA=Y
#       - SA_PASSWORD=YourStrong@Passw0rd
#     # ports:                        # Port exposure is OPTIONAL in same-stack
#     #   - "1433:1433"               # Only needed if you want host access too
#     volumes:
#       - sql-data:/var/opt/mssql
#
# volumes:
#   sql-data:
#     driver: local
